package com.worldpay.pms.cue.engine.scenario;

import static com.worldpay.pms.cue.engine.integration.Constants.CISADM_OUTPUT_TABLES;
import static com.worldpay.pms.cue.engine.integration.Constants.OUTPUT_TABLES;
import static com.worldpay.pms.cue.engine.utils.DatabaseCsvUtils.readFromCsvFileAndDeleteFromTable;
import static com.worldpay.pms.cue.engine.utils.DatabaseCsvUtils.readFromCsvFileAndWriteToExistingTable;
import static com.worldpay.pms.spark.core.Resource.resourceAsString;
import static com.worldpay.pms.spark.core.SparkApp.run;
import static java.lang.String.format;
import static org.assertj.core.api.Assertions.assertThat;

import com.google.common.collect.Sets;
import com.typesafe.config.ConfigBeanFactory;
import com.typesafe.config.ConfigFactory;
import com.worldpay.pms.cue.engine.InMemoryStaticDataRepository;
import com.worldpay.pms.cue.engine.utils.WithDatabaseAndSpark;
import com.worldpay.pms.spark.core.jdbc.JdbcConfiguration;
import com.worldpay.pms.spark.core.jdbc.SqlDb;
import io.vavr.collection.List;
import java.time.LocalDate;
import java.time.Month;
import java.util.Collections;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.sql2o.Query;
import org.sql2o.Sql2oQuery;
import org.sql2o.data.Row;
import org.sql2o.data.Table;

public class MigrationTest implements WithDatabaseAndSpark {

  private SqlDb appuserDb;
  private static final SqlDb cisadmAcct =
      SqlDb.simple(
          ConfigBeanFactory.create(
              ConfigFactory.load("conf/db.conf").getConfig("cisadm"), JdbcConfiguration.class));

  @Override
  public void bindChargingJdbcConfiguration(JdbcConfiguration conf) {
    this.appuserDb = SqlDb.simple(conf);
  }

  private InMemoryStaticDataRepository.InMemoryStaticDataRepositoryBuilder staticData;

  @BeforeEach
  void setup() {
    staticData = InMemoryStaticDataRepository.builder();
  }

  @Test
  void testMigration() {

    // Load static data
    staticData
        .chargeTypes(Collections.emptySet())
        .currencyCodes(Sets.newHashSet("GBP", "EUR"))
        .priceItems(Sets.newHashSet("ADHOCCHG", "MIGCHBK"))
        .subAccountTypes(Sets.newHashSet("CHRG", "RECR", "CHBK"))
        .billPeriodCodes(Sets.newHashSet("WPDY", "WPMO"));

    // load some data in cm_misc_bill_item to migrate
    readFromCsvFileAndWriteToExistingTable(
        appuserDb, "input/scenario/cm_misc_bill_item.csv", "cm_misc_bill_item");

    // already existing some migrated charges for source_id
    readFromCsvFileAndWriteToExistingTable(
        appuserDb, "input/scenario/cm_rec_chg.csv", "cm_rec_chg");

    // insert a completed batch entry
    readFromCsvFileAndWriteToExistingTable(
        appuserDb, "input/scenario/batch_history.csv", "batch_history");

    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct, "input/scenario/ci_bill_cyc_sch.csv", "ci_bill_cyc_sch");

    // run the migration script before spark run
    appuserDb.execQuery(
        "running migration query",
        resourceAsString("input/scenario/migration.sql"),
        Query::executeUpdate);

    // check data is populated or not
    // total records migrated
    assertThat(readFromViewRecrIdfr(null).size()).isEqualTo(4);
    // assert that only max_cutt_off_dt of particular source_id migrated

    assertThat(
            readFromViewRecrIdfr(
                    "source_id='113' and cutoff_dt = TO_DATE('14-MAR-2021','DD-MON-YYYY')")
                .size())
        .isEqualTo(1);

    // run spark job
    submit(LocalDate.of(2021, Month.MARCH, 15));

    // assert output
    assertThat(readBillItems(null).size()).isEqualTo(15);

    // assert charges generated by current batch
    assertThat(readBillItemTable("batch_code<>'test-run' and source_id='111'").size()).isEqualTo(3);
    assertThat(readBillItemTable("batch_code<>'test-run' and source_id='112'").size()).isEqualTo(3);
    assertThat(readBillItemTable("batch_code<>'test-run' and source_id='113'").size()).isEqualTo(1);
    assertThat(readBillItemTable("batch_code<>'test-run' and source_id='114'").size()).isEqualTo(2);
  }

  public void submit(LocalDate logicalDate) {
    submit(logicalDate.toString());
  }

  public void submit(String logicalDate) {
    run(
        cfg -> new ScenarioApp(cfg, staticData.build()),
        "submit",
        "--force",
        "--logical-date",
        logicalDate);
  }

  // helper assert methods
  protected List<Row> readFromViewRecrIdfr(String where) {
    return List.ofAll(readTable("vw_rec_idfr", where).rows());
  }

  protected List<Row> readBillItems(String where) {
    return List.ofAll(readTable("vw_misc_bill_item", where).rows());
  }

  protected List<Row> readBillItemTable(String where) {
    return List.ofAll(readTable("cm_misc_bill_item", where).rows());
  }

  protected Table readTable(String tableName, String where) {
    return appuserDb.execQuery(
        tableName,
        format("SELECT * FROM %s WHERE %s", tableName, where == null ? "1=1" : where),
        Sql2oQuery::executeAndFetchTable);
  }

  @BeforeAll
  static void setUpAccounts() {
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_acct.csv",
        "ci_acct",
        "acct_id");
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_acct_per.csv",
        "ci_acct_per",
        "acct_id");
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_per_id.csv",
        "ci_per_id",
        "per_id");
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct, "input/ChargingEndToEndTest/account_determination/ci_sa.csv", "ci_sa", "sa_id");
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_sa_char.csv",
        "ci_sa_char",
        "sa_id");
    readFromCsvFileAndDeleteFromTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_cis_div_char.csv",
        "ci_cis_div_char",
        "cis_division");

    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct, "input/ChargingEndToEndTest/account_determination/ci_acct.csv", "ci_acct");
    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_acct_per.csv",
        "ci_acct_per");
    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct, "input/ChargingEndToEndTest/account_determination/ci_per_id.csv", "ci_per_id");
    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct, "input/ChargingEndToEndTest/account_determination/ci_sa.csv", "ci_sa");
    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_sa_char.csv",
        "ci_sa_char");
    readFromCsvFileAndWriteToExistingTable(
        cisadmAcct,
        "input/ChargingEndToEndTest/account_determination/ci_cis_div_char.csv",
        "ci_cis_div_char");
    cisadmAcct.execQuery(
        "refresh materialized view",
        "{CALL CBE_CUE_OWNER.PKG_CHARGING_ENGINE.prc_refresh_bcu_account()}",
        Sql2oQuery::executeUpdate);
  }

  @AfterEach
  void cleanUp() {
    appuserDb.exec(
        "clear tables - user",
        conn -> {
          OUTPUT_TABLES.forEach(
              out -> {
                try (Query q = conn.createQuery(format("DELETE %s", out))) {
                  q.executeUpdate();
                }
              });
          return true;
        });
    cisadmAcct.exec(
        "clear tables - cisadm",
        conn -> {
          CISADM_OUTPUT_TABLES.forEach(
              out -> {
                try (Query q = conn.createQuery(format("DELETE %s", out))) {
                  q.executeUpdate();
                }
              });
          return true;
        });
    cisadmAcct.execQuery("clear input table", "delete from  cm_bchg_stg", Query::executeUpdate);
    cisadmAcct.execQuery("clear input table", "delete from  ci_bill_cyc_sch", Query::executeUpdate);
  }

  @BeforeEach
  void clean() {
    appuserDb.exec(
        "clear tables - user",
        conn -> {
          OUTPUT_TABLES.forEach(
              out -> {
                try (Query q = conn.createQuery(format("DELETE %s", out))) {
                  q.executeUpdate();
                }
              });
          return true;
        });
    cisadmAcct.exec(
        "clear tables - cisadm",
        conn -> {
          CISADM_OUTPUT_TABLES.forEach(
              out -> {
                try (Query q = conn.createQuery(format("DELETE %s", out))) {
                  q.executeUpdate();
                }
              });
          return true;
        });
    cisadmAcct.execQuery("clear input table", "delete from  cm_bchg_stg", Query::executeUpdate);
    cisadmAcct.execQuery("clear input table", "delete from  ci_bill_cyc_sch", Query::executeUpdate);
  }
}
